# Карта проекта

> **Главное правило:** любые планы, изменения планов и отметки о выполнении фиксируются **только** в этом файле. Если появился новый пункт плана — добавляем его сюда, завершили шаг — ставим отметку `[x]` напротив соответствующей строки.

> **Второе правило:** Мы пишем надежный код на Cи, поэтому стараемся использовать power of ten rules NASA:
1. Avoid complex flow constructs, such as goto and recursion.
1. All loops must have fixed bounds. This prevents runaway code.
1. Avoid heap memory allocation after initialization.
1. Restrict functions to a single printed page.
1. Use a minimum average of two runtime assertions per function.
1. Restrict the scope of data to the smallest possible.
1. Check the return value of all non-void functions, or cast to void to indicate the return value is useless.
1. Use the preprocessor only for header files and simple macros.
1. Limit pointer use to a single dereference, and do not use function pointers.
1. Compile with all possible warnings active; all warnings should then be addressed before release of the software.

## Верхнеуровневая структура
- `Makefile` — собирает два бинарника: `a` (сервер) и `b` (клиент); цель `all` также делает статические варианты.
- `server.c` — реализация L2-сервера: ждет init-кадр от клиента, запускает описанную в нем команду в PTY и прокидывает байты через Ethernet.
- `client.c` — реализация L2-клиента: принимает имя удаленной команды третьим позиционным аргументом (`/bin/bash`, `/bin/sh` и т.д.), шлет init-кадр с этим значением, читает ввод пользователя, шифрует его и отправляет на сервер, а ответ выводит в терминал. Опциональный четвертый аргумент отправляется как one-shot команда и завершает клиента после получения ответа.
- `common.c/.h` — общие типы пакетов, шифрование и контрольная сумма.
- `l2shell_kmod.c` — экспериментальный in-kernel транспорт-триггер: слушает кастомный EtherType, ловит init-пакет клиента и через `call_usermodehelper` запускает указанную команду, не поднимая пользовательских устройств.
- `README.md` — краткая инструкция по сборке и запуску.
- `scripts/` — служебные скрипты, в т.ч. `test_local.sh` для end-to-end теста через veth.
- `tests/` — юнит-тесты общих хелперов (`tests/common_tests.c`, shared-хедер `tests/test_common_shared.h`).
- `test_util.h` — минимальный тестовый раннер + перехват аллокаторов для fault-injection; используется тестами без внешних зависимостей.
- `test_logs/` — вывод локальных тестов.

## Общие концепции
- Пользовательский EtherType `0x88B5`, структура `pack_t` содержит Ethernet-заголовок, сигнатуру отправителя и до 1024 байт полезной нагрузки.
- Подписи `CLIENT_SIGNATURE` и `SERVER_SIGNATURE` позволяют фильтровать «свои» кадры.
- `enc_dec` — симметричное XOR-«шифрование» с ключом на базе CRC и соли `key_magic`.
- `calculate_checksum` пишет простую покадровую сумму в поле `crc`; перед расчетом поле очищается на обеих сторонах.
- **Стиль кодирования**: K&R, 4 пробела на отступ, брейсы на той же строке с сигнатурой. Функции/глобальные переменные именуются `lowercase_with_underscores`. Стараемся не переносить сигнатуры и вызовы функций на две строки даже при превышении мягкого лимита в 80 символов. Любой новый код обязан следовать этим правилам и списку Power-of-Ten из начала файла. Предпочитаем `static inline` хелперы в `common.h`, а не макросы.
- **Rule of Least Surprise**: все сообщения, предупреждения и поведение должны быть очевидными человеку, читающему вывод. Если негативный сценарий теста выводит `error`, рядом должно быть пояснение, что это ожидаемо и почему.

## Типы и вспомогательные функции
- `packh_t`/`pack_t` — общие для клиента и сервера заголовок+payload.
- `build_packet`/`parse_packet` — сборка и проверка кадров (добавление MAC-ов, сигнатур, CRC, шифрование/дешифрование).
- `write_all` — повторно пытается отправить данные из PTY при коротких или прерванных записях.

## Сервер (`server.c`)
1. **Инициализация**
   - Создает `AF_PACKET/SOCK_RAW` сокет, биндит к интерфейсу, вытаскивает MAC через `SIOCGIFHWADDR`.
   - Запускает PTY через `forkpty` и хранит master-фд в `sh_fd`.
   - Переходит в цикл `select` по сокету и PTY.
2. **Прием (`handle_client_read`)**
   - `recvfrom`, проверка EtherType, сигнатуры, MAC (широковещательный или наш, не loopback).
   - Если PTY еще не поднят, полезная нагрузка трактуется как строка команды (`launch_remote_command`) и запускает процесс. Данные не прокидываются в PTY.
   - После запуска PTY `parse_packet` возвращает полезную нагрузку; байты сразу пишутся в PTY.
3. **Передача (`handle_client_write`)**
   - Читает PTY, собирает Ethernet-кадр с последним MAC клиента, шифрует payload, пересчитывает CRC и делает `sendto`.
4. **Жизненный цикл**
   - Таймаут 10 секунд без трафика закрывает PTY.
   - Завершение дочернего процесса приводит к очистке `sh_fd` и ожиданию нового запуска.

## Клиент (`client.c`)
1. **Инициализация контекста**
   - Читает аргументы `<iface> <server-mac> <remote-shell> [one-shot]`, валидирует MAC, заполняет `client_ctx` (сокет, `sockaddr_ll`, дедуп-кэш).
   - Настраивает RAW-сокет (`SO_RCVTIMEO`), сохраняет MAC интерфейса, готовит структуру отправки.
2. **TTY / ввод**
   - `set_raw_mode` пытается открыть `/dev/tty`, сохранить исходный `termios` и перевести его в raw; при недоступности TTY клиент переходит в read-only режим и пишет предупреждение.
   - Ввод с клавиатуры прогоняется через `normalize_cr`, чтобы сервер всегда получал LF.
3. **Отправка**
   - `send_packet` — единая функция сборки и отправки кадра (MAC, CRC, шифрование).
   - `send_init_frame` отправляет строку удаленной команды (третья позиция CLI); после этого интерактивный ввод шлется через `handle_stdin`, one-shot команда (четвертый аргумент) — через одноразовый вызов `send_packet`.
4. **Прием**
   - `handle_socket_rx` проверяет EtherType/подпись, дедуплицирует, обновляет MAC сервера, расшифровывает payload и печатает его; для one-shot режима продлевает дедлайн ответа.
5. **Главный цикл**
   - `pump_events` строит `fd_set` из сокета и TTY, вызывает `select`, обрабатывает готовые дескрипторы. Таймауты переводятся из ns в `timeval` с безопасным ограничением `INT_MAX`, что исключает спонтанные wakeup'ы.
6. **Режимы запуска**
   - `--tty-loop` оставлен для локальной проверки эха (без сетевого стека).
   - One-shot режим (четвертый аргумент) отправляет команду, ждет ответ `COMMAND_RESPONSE_TIMEOUT_NS` и завершает клиента.

## Kernel-модуль (`l2shell_kmod.c`)
- Регистрирует `packet_type` на `ETHER_TYPE_CUSTOM` для **всех** интерфейсов и просто слушает кадры клиента.
- Дедуплицирует фреймы (`dedup_cache`), расшифровывает payload и при первом ненулевом пакете сохраняет строку команды, прилетевшую в init-кадре.
- Команда запускается через `call_usermodehelper()` (обёртка с `setsid /bin/bash -c "<строка>"`). Модуль не поднимает устройств и не занимается PTY: всё, что нужно для связи, делает запускаемая команда (обычно ревшелл).
- Поддерживается один активный клиент (последний MAC/интерфейс). После завершения работы можно снова отправить init-кадр и запустить новую команду.

## Сборка и запуск
1. `make` — компилирует `a`, `b`, а также `a_static`, `b_static`.
2. Сервер: `./a <iface>` (пример: `./a eth1`). Команда выбирается клиентом при первом пакете.
3. Клиент: `./b <iface> <mac> <remote shell cmd> [one-shot command]` (пример: `./b eth1 11:22:33:44:55:66 /bin/bash "echo 123"`). Пока сервер не ответил, клиент шлет broadcast.

## Тестирование и скрипты
- `scripts/test_local.sh` поднимает мост `br_l2shell0` + `veth_srv0/veth_cli0`, запускает `./a veth_srv0` и `./b veth_cli0 <mac> /bin/bash "echo 123"`, складывая логи в `test_logs/server.log` и `test_logs/client.log`. Скрипт требует `sudo` (создает veth), сам очищает интерфейсы в `trap cleanup`.
- `sudo make test` — оболочка над `scripts/test_local.sh`.
- `make test-unit` собирает/запускает `tests/common_tests.c`. Легковесный раннер (`test_util.h`) намеренно печатает строки `error: payload size too large`/`error: crc mismatch` в негативных сценариях — это не падения.
- Логи тестов хранятся в `test_logs/` и нарочно не чистятся `make clean`, чтобы можно было проанализировать вывод после падения.

## План работ
### Активные задачи
- _пусто_
### Завершенные задачи
- [x] Переписать `client.c` в стиле Power-of-Ten: контекстная структура, единые хелперы `send_packet`/`handle_socket_rx`, нормализация CR→LF и четкий `select`-цикл без ложных wakeup'ов.
- [x] Перенести выбор удаленной команды на клиента: первый init-кадр содержит строку с удаленной командой (третья позиция CLI), сервер без аргумента запускается `./a <iface>` и стартует процесс только по этому кадру.
- [x] Исправить использование MAC-адреса назначения в интерактивной отправке (`client.c:206-230`) и стартовом пакете (`client.c:428-455`): клиент обязан отправлять кадры на MAC, переданный через CLI, даже до первого ответа.
- [x] Перед вызовом `recvfrom` в `client.c:139-145` заполнять `socklen_t saddr_len = sizeof(*saddr)`; сейчас нулевое значение ломает прием на некоторых ядрах.
- [x] `handle_server_read` (client.c:139-188) печатает payload даже после `error: crc mismatch`, что позволяет битому трафику попадать в терминал. Нужно сразу возвращать ошибку и ничего не писать.
- [x] Переписать таймер простоя в `server.c:189-201`, чтобы `last_data_time` обновлялся только при реальных данных, иначе PTY никогда не гаснет.
- [x] Обрабатывать код возврата `select` в `server.c:276-294`, повторно вызывать при `EINTR` и не трогать `FD_SET`, если `select` вернул ошибку.
- [x] Выровнять порядок байт CRC между userland (`common.c:32-86`) и kmod (`l2shell_kmod.c:108-190`); сейчас юзерленд кладет checksum в host-endian, а модуль сериализует через `cpu_to_be32`, из-за чего они не совместимы.
- [x] Настроить `make test-unit` на использование встроенного `test_util.h`, перенести тесты в `tests/common_tests.c`.
- [x] Вынести сборку/парсинг пакетов в общие функции `build_packet`/`parse_packet`.
- [x] Синхронизировать реализацию CRC и XOR в клиенте и сервере.
- [x] Обеспечить корректный запуск PTY после первого payload без потери байтов.
- [x] Добавить дедупликацию L2-фреймов на клиенте и сервере, чтобы мосты/широковещательные повторы не дублировали ввод.
- [x] Научить `Makefile` собирать/запускать `make test-unit` и задокументировать запуск в `README.md`.
- [x] Расширить `tests/common_tests.c` дополнительными сценариями (NULL-аргументы, проверки endian, негативные случаи `parse_packet`, дедуп по времени).
- [x] Переделать `l2shell_kmod.c` в init-триггер: при первом payload клиента запускает команду через `call_usermodehelper`, вместо старого символьного интерфейса.
