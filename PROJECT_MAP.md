# Карта проекта

> **Главное правило:** любые планы, изменения планов и отметки о выполнении фиксируются **только** в этом файле. Если появился новый пункт плана — добавляем его сюда, завершили шаг — ставим отметку `[x]` напротив соответствующей строки.

> **Второе правило:** Мы пишем надежный код на си, поэтому стараемся использовать power of ten rules NASA:
1. Avoid complex flow constructs, such as goto and recursion.
1. All loops must have fixed bounds. This prevents runaway code.
1. Avoid heap memory allocation after initialization.
1. Restrict functions to a single printed page.
1. Use a minimum average of two runtime assertions per function.
1. Restrict the scope of data to the smallest possible.
1. Check the return value of all non-void functions, or cast to void to indicate the return value is useless.
1. Use the preprocessor only for header files and simple macros.
1. Limit pointer use to a single dereference, and do not use function pointers.
1. Compile with all possible warnings active; all warnings should then be addressed before release of the software.

## Верхнеуровневая структура
- `Makefile` — собирает два бинарника: `a` (сервер) и `b` (клиент); цель `all` также делает статические варианты.
- `server.c` — реализация L2-сервера: создает PTY с указанной командой и прокидывает байты через Ethernet.
- `client.c` — реализация L2-клиента: читает ввод пользователя, шифрует его и отправляет на сервер, а ответ выводит в терминал.
- `common.c/.h` — общие типы пакетов, шифрование и контрольная сумма.
- `l2shell_kmod.c` — экспериментальный in-kernel транспорт: регистрирует `/dev/l2sh`, слушает кастомный EtherType и ретранслирует payload между последним клиентом и пользовательским приложением.
- `README.md` — краткая инструкция по сборке и запуску.
- `scripts/` — служебные скрипты, в т.ч. `test_local.sh` для end-to-end теста через veth.
- `tests/` — юнит-тесты общих хелперов (`tests/common_tests.c`, shared-хедер `tests/test_common_shared.h`).
- `test_util.h` — минимальный тестовый раннер + перехват аллокаторов для fault-injection; используется тестами без внешних зависимостей.
- `test_logs/` — вывод локальных тестов.

## Общие концепции
- Пользовательский EtherType `0x88B5`, структура `pack_t` содержит Ethernet-заголовок, сигнатуру отправителя и до 1024 байт полезной нагрузки.
- Подписи `CLIENT_SIGNATURE` и `SERVER_SIGNATURE` позволяют фильтровать «свои» кадры.
- `enc_dec` — симметричное XOR-«шифрование» с ключом на базе CRC и соли `key_magic`.
- `calculate_checksum` пишет простую покадровую сумму в поле `crc`; перед расчетом поле очищается на обеих сторонах.
- **Стиль кодирования**: K&R, 4 пробела на отступ, брейсы на той же строке с сигнатурой. Функции/глобальные переменные именуются `lowercase_with_underscores`. Стараемся не переносить сигнатуры и вызовы функций на две строки даже при превышении мягкого лимита в 80 символов. Любой новый код обязан следовать этим правилам и списку Power-of-Ten из начала файла. Предпочитаем `static inline` хелперы в `common.h`, а не макросы.
- **Rule of Least Surprise**: все сообщения, предупреждения и поведение должны быть очевидными человеку, читающему вывод. Если негативный сценарий теста выводит `error`, рядом должно быть пояснение, что это ожидаемо и почему.

## Типы и вспомогательные функции
- `packh_t`/`pack_t` — общие для клиента и сервера заголовок+payload.
- `build_packet`/`parse_packet` — сборка и проверка кадров (добавление MAC-ов, сигнатур, CRC, шифрование/дешифрование).
- `write_all` — повторно пытается отправить данные из PTY при коротких или прерванных записях.

## Сервер (`server.c`)
1. **Инициализация**
   - Создает `AF_PACKET/SOCK_RAW` сокет, биндит к интерфейсу, вытаскивает MAC через `SIOCGIFHWADDR`.
   - Запускает PTY через `forkpty` и хранит master-фд в `sh_fd`.
   - Переходит в цикл `select` по сокету и PTY.
2. **Прием (`handle_client_read`)**
   - `recvfrom`, проверка EtherType, сигнатуры, MAC (широковещательный или наш, не loopback).
   - `parse_packet` возвращает полезную нагрузку; байты сразу пишутся в PTY.
3. **Передача (`handle_client_write`)**
   - Читает PTY, собирает Ethernet-кадр с последним MAC клиента, шифрует payload, пересчитывает CRC и делает `sendto`.
4. **Жизненный цикл**
   - Таймаут 10 секунд без трафика закрывает PTY.
   - Завершение дочернего процесса приводит к очистке `sh_fd` и ожиданию нового запуска.

## Клиент (`client.c`)
1. **Инициализация**
   - Принимает имя интерфейса и MAC сервера (или broadcast при старте), проверяет формат строки.
   - Создает raw-сокет, переводит его в неблокирующий режим с `SO_RCVTIMEO`.
   - Отправляет стартовый широковещательный пакет с клиентской сигнатурой.
2. **Терминал**
   - Переводит STDIN в неканонический режим, отключает echo (пока опция `--local-echo` реализована частично).
3. **Передача (`handle_server_write`)**
   - Читает посимвольно c STDIN, ставит размер payload, подпись клиента, MAC назначения (сервер или broadcast), считает CRC, шифрует и отправляет `sendto`.
4. **Прием (`handle_server_read`)**
   - Проверяет EtherType/сигнатуру сервера, при первом ответе сохраняет MAC сервера.
   - Дешифрует payload, перепроверяет CRC, пишет вывод на STDOUT.
5. **Главный цикл**
   - `select` слушает STDIN и сокет, переключая в нужный обработчик.
6. **Режимы запуска**
   - `--tty-loop` позволяет проверить локальную обработку TTY без сетевого сокета (эхом прогоняет stdin→stdout).
   - Передача третьего позиционного аргумента трактуется как one-shot команда: `send_text_command` добавляет `\r`, ждет ответ `COMMAND_RESPONSE_TIMEOUT_NS` и завершает клиента по таймауту.

## Kernel-модуль (`l2shell_kmod.c`)
- Регистрирует `packet_type` на `ETHER_TYPE_CUSTOM` и misc-устройство `/dev/l2sh`. Любой `write()` в девайс вызывает `tx_payload`, который собирает Ethernet-кадр с `SERVER_SIGNATURE` и отправляет его последнему известному клиенту через `dev_queue_xmit`.
- `l2_rx` принимает кадры с `CLIENT_SIGNATURE`, проверяет размер/CRC, выполняет `enc_dec`, обрезает дубликаты через `dedup_cache` и помещает payload в кольцевой буфер `RX_BUF_SZ` (64 КБ) под спинлоком.
- Пользовательское чтение (`read()`) блокируется через `wait_event_interruptible`, поддерживает неблокирующий режим и возвращает столько байтов, сколько доступно.
- Поддерживаются только одиночные открытия (`open_cnt`), чтобы один процесс владел `/dev/l2sh`. Обнуление состояния (`g.have_cli`, `g.dev`) не делается автоматически при уходе клиента.
- CRC в модуле сериализуется через `cpu_to_be32`, а это расходится с пользовательским `common.c`, где CRC кладется в кадр в host-endian. Пока никто не выровняет порядок байт, kmod и юзерленд бинарники не совместимы.

## Сборка и запуск
1. `make` — компилирует `a`, `b`, а также `a_static`, `b_static`.
2. Сервер: `./a <iface> <команда>` (пример: `./a eth1 bash`).
3. Клиент: `./b <iface> <mac>` (пример: `./b eth1 11:22:33:44:55:66`). Пока сервер не ответил, клиент шлет broadcast.

## Тестирование и скрипты
- `scripts/test_local.sh` поднимает мост `br_l2shell0` + `veth_srv0/veth_cli0`, запускает `./a veth_srv0 /bin/bash` и `./b veth_cli0 <mac> "echo 123"`, складывая логи в `test_logs/server.log` и `test_logs/client.log`. Скрипт требует `sudo` (создает veth), сам очищает интерфейсы в `trap cleanup`.
- `sudo make test` — оболочка над `scripts/test_local.sh`.
- `make test-unit` собирает/запускает `tests/common_tests.c`. Легковесный раннер (`test_util.h`) намеренно печатает строки `error: payload size too large`/`error: crc mismatch` в негативных сценариях — это не падения.
- Логи тестов хранятся в `test_logs/` и нарочно не чистятся `make clean`, чтобы можно было проанализировать вывод после падения.

## План работ
### Активные задачи
- _пусто_
### Завершенные задачи
- [x] Исправить использование MAC-адреса назначения в интерактивной отправке (`client.c:206-230`) и стартовом пакете (`client.c:428-455`): клиент обязан отправлять кадры на MAC, переданный через CLI, даже до первого ответа.
- [x] Перед вызовом `recvfrom` в `client.c:139-145` заполнять `socklen_t saddr_len = sizeof(*saddr)`; сейчас нулевое значение ломает прием на некоторых ядрах.
- [x] `handle_server_read` (client.c:139-188) печатает payload даже после `error: crc mismatch`, что позволяет битому трафику попадать в терминал. Нужно сразу возвращать ошибку и ничего не писать.
- [x] Переписать таймер простоя в `server.c:189-201`, чтобы `last_data_time` обновлялся только при реальных данных, иначе PTY никогда не гаснет.
- [x] Обрабатывать код возврата `select` в `server.c:276-294`, повторно вызывать при `EINTR` и не трогать `FD_SET`, если `select` вернул ошибку.
- [x] Выровнять порядок байт CRC между userland (`common.c:32-86`) и kmod (`l2shell_kmod.c:108-190`); сейчас юзерленд кладет checksum в host-endian, а модуль сериализует через `cpu_to_be32`, из-за чего они не совместимы.
- [x] Настроить `make test-unit` на использование встроенного `test_util.h`, перенести тесты в `tests/common_tests.c`.
- [x] Вынести сборку/парсинг пакетов в общие функции `build_packet`/`parse_packet`.
- [x] Синхронизировать реализацию CRC и XOR в клиенте и сервере.
- [x] Обеспечить корректный запуск PTY после первого payload без потери байтов.
- [x] Добавить дедупликацию L2-фреймов на клиенте и сервере, чтобы мосты/широковещательные повторы не дублировали ввод.
- [x] Научить `Makefile` собирать/запускать `make test-unit` и задокументировать запуск в `README.md`.
- [x] Расширить `tests/common_tests.c` дополнительными сценариями (NULL-аргументы, проверки endian, негативные случаи `parse_packet`, дедуп по времени).
